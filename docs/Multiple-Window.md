# 2.6 支持多种窗口系统

外观和感觉是众多可移植性问题中的一个，另一个是 Lexi 运行的窗口环境。一个平台的窗口系统在位图显示上创建多个重叠窗口的假象，它管理窗口的屏幕空间，并将键盘和鼠标的输入路由到各个窗口。目前存在几种重要且基本不兼容的窗口系统（例如，Macintosh、Presentation Manager、Windows、X）。我们希望 Lexi 能在尽可能多的窗口系统上运行，原因与我们支持多种外观和感觉标准相同。

## 我们能否使用抽象工厂模式？

乍一看，这可能是应用抽象工厂模式的另一个机会。但窗口系统的可移植性约束与外观和感觉独立性约束有所不同。

在应用抽象工厂模式时，我们假设为每种外观和感觉标准定义具体的控件图形类。这意味着我们可以从一个抽象产品类（如 ScrollBar）派生出每个外观和感觉标准的具体产品（如 MotifScrollBar 和 MacScrollBar）。但假设我们已经有了来自不同供应商的多个类层次结构，每个外观和感觉标准都有一个类层次结构。当然，这些层次结构不太可能兼容。因此，我们不能为每种控件（ScrollBar、Button、Menu 等）提供一个共同的抽象产品类——如果没有这些关键类，抽象工厂模式就无法工作。我们必须使不同的控件层次结构遵循一组共同的抽象产品接口，只有这样，才能在抽象工厂的接口中正确声明 Create... 操作。

我们通过开发自己的抽象和具体产品类解决了控件的问题。现在，在尝试让 Lexi 在现有的窗口系统上运行时，我们面临类似的问题：不同的窗口系统具有不兼容的编程接口。事情变得更棘手了，因为我们无法实现自己的非标准窗口系统。

但幸运的是，像外观和感觉标准一样，窗口系统接口之间的差异并不大，因为所有窗口系统基本上都做同样的事情。我们需要一组统一的窗口抽象，它可以让我们将不同的窗口系统实现放在一个共同的接口之下。

## 封装实现依赖

在 2.2 节中，我们介绍了用于在显示屏上显示图形或图形结构的 `Window` 类。我们没有指定该对象所使用的窗口系统，因为它实际上并不来自任何特定的窗口系统。`Window` 类封装了窗口在不同窗口系统中通常会做的事情：

- 提供绘制基本几何形状的操作。
- 可以最小化和还原自身。
- 可以调整大小。
- 可以按需重新绘制内容，例如当窗口还原或当一个被覆盖的部分暴露时。

`Window` 类必须跨越不同窗口系统的功能。我们来考虑两种极端的设计理念：

1. **功能交集**：`Window` 类接口仅提供所有窗口系统共享的功能。这个方法的问题在于，`Window` 接口的功能将与最不具能力的窗口系统一致。即使大多数窗口系统支持更高级的特性，我们也无法利用这些特性。
   
2. **功能并集**：创建一个接口，结合所有现有系统的功能。问题在于，结果接口可能会非常庞大且不连贯。而且，每当供应商修改其窗口系统接口时，我们就必须改变它（以及依赖于它的 Lexi）。

这两种极端方案都不可行，所以我们的设计将在两者之间找到一个平衡点。`Window` 类将提供一个方便的接口，支持最常见的窗口功能。因为 Lexi 将直接处理这个类，`Window` 类的接口还必须包括一个基本的图形操作集，让图形在窗口中绘制自己。下表列出了 `Window` 类接口的一部分操作：

| 操作            | 责任          |
|-----------------|---------------|
| `Redraw()`      | 虚拟操作      |
| `Raise()`       | 虚拟操作      |
| `Lower()`       | 虚拟操作      |
| `Iconify()`     | 虚拟操作      |
| `Deiconify()`   | 虚拟操作      |
| `DrawLine()`    | 虚拟操作      |
| `DrawRect()`    | 虚拟操作      |
| `DrawPolygon()` | 虚拟操作      |
| `DrawText()`    | 虚拟操作      |

`Window` 是一个抽象类，具体的子类支持用户处理的不同类型窗口。例如，应用窗口、图标和警告对话框都是窗口，但它们的行为有所不同。因此，我们可以定义诸如 `ApplicationWindow`、`IconWindow` 和 `DialogWindow` 等子类来捕捉这些差异。最终的类层次结构为像 Lexi 这样的应用程序提供了一个统一且直观的窗口抽象，它不依赖于任何特定供应商的窗口系统。

## 实现 `Window` 类

现在我们定义了一个 Lexi 使用的窗口接口，那么平台特定的窗口是如何实现的呢？如果我们不实现自己的窗口系统，那么在某个时刻，窗口抽象必须根据目标窗口系统提供的内容来实现。那么，如何管理实现呢？

一种方法是为每个窗口平台实现 `Window` 类及其子类的多个版本。我们必须在为给定平台构建 Lexi 时选择一个版本。但是想象一下，维护这些类的困难，所有类都叫做 "Window"，但每个类都在不同的窗口系统上实现。或者，我们可以为 `Window` 层次结构中的每个类创建实现特定的子类——结果会再次出现子类爆炸的问题。这两种替代方案还有一个缺点：它们都无法提供在编译程序后更改窗口系统的灵活性。因此，我们还需要保留多个不同的可执行文件。

这两种方法都不理想，但我们该怎么办呢？我们可以采取与格式和修饰类似的方式，封装变化的部分。变化的部分是窗口系统的实现。如果我们将窗口系统的功能封装在一个对象中，那么我们就可以根据该对象的接口实现 `Window` 类及其子类。更重要的是，如果该接口能够为我们关注的所有窗口系统提供支持，那么我们就不需要修改 `Window` 类或它的任何子类来支持不同的窗口系统。我们可以通过传递合适的窗口系统封装对象来配置窗口对象，甚至可以在运行时配置窗口。

## `Window` 和 `Windowlmp`

我们将定义一个单独的 `Windowlmp` 类层次结构，用于隐藏不同窗口系统的实现。`Windowlmp` 是一个抽象类，用于封装窗口系统相关的代码。为了让 Lexi 在特定的窗口系统上工作，我们会为每个窗口对象配置一个 `Windowlmp` 子类的实例。下图展示了 `Window` 和 `Windowlmp` 层次结构之间的关系：

通过将实现隐藏在 `Windowlmp` 类中，我们避免了将窗口系统的依赖污染到 `Window` 类中，从而使 `Window` 类层次结构保持较小且稳定。同时，我们可以轻松扩展实现层次结构，以支持新的窗口系统。

## `Windowlmp` 子类

`Windowlmp` 的子类将请求转换为特定窗口系统的操作。考虑我们在 2.2 节中使用的例子，我们通过 `Window` 实例的 `DrawRect` 操作来定义 `Rectangle::Draw`：

```cpp
void Rectangle::Draw (Window* w) {
    w->DrawRect(_x0, _y0, _xl, _yl);
}
