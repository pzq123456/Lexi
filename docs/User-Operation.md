## 2.7 用户操作

Lexi 的部分功能可以通过文档的 WYSIWYG 表现来访问。您可以在文档中输入和删除文本、移动插入点、选择文本范围，通过指向、点击和直接在文档中输入来进行操作。其他功能则通过 Lexi 的下拉菜单、按钮和键盘加速器间接访问。这些功能包括：

- 创建新文档
- 打开、保存和打印现有文档
- 剪切选定文本并粘贴回文档
- 更改选定文本的字体和样式
- 更改文本的格式，例如对齐和排版
- 退出应用程序
- 以及其他操作

Lexi 为这些操作提供了不同的用户界面。但是，我们不想将某个特定的用户操作与某个特定的用户界面关联，因为我们可能希望通过多种用户界面来访问同一操作（例如，您可以通过页面按钮或菜单操作翻页）。我们还可能希望在未来更改界面。

此外，这些操作实现于多个不同的类中。作为实现者，我们希望能够访问这些功能，而不创建过多的依赖关系，这样做会导致实现和用户界面类之间的紧密耦合，使得系统更难理解、扩展和维护。

更复杂的是，我们希望 Lexi 支持大部分操作的撤销和重做功能，但并非所有操作都需要撤销。例如，我们希望能够撤销文档修改操作（如删除），因为用户可能会不小心删除大量数据。但我们不应该尝试撤销像保存绘图或退出应用程序这样的操作。这些操作不应影响撤销过程。而且，我们也不希望撤销和重做的级别受到任意限制。

显然，用户操作的支持贯穿整个应用程序。挑战在于设计一个简单且可扩展的机制，满足所有这些需求。

### 封装请求

从设计者的角度来看，下拉菜单只不过是另一种包含其他图形的符号。与其他含有子项的符号不同，下拉菜单中的大多数图形会响应一次点击来执行某个操作。

假设这些执行操作的图形是一个名为 `Menultem` 的 Glyph 子类实例，并且它们响应来自客户端的请求。执行请求可能涉及一个对象的操作，也可能是多个对象的多个操作，或两者之间的某种组合。

我们可以为每个用户操作定义一个 `Menultem` 子类，然后通过硬编码每个子类来执行请求。但这样做并不完全正确，因为我们不需要为每个请求都定义一个子类，就像我们不需要为每个下拉菜单中的文本字符串定义一个子类一样。此外，这种方式将请求与特定的用户界面紧密耦合，使得在不同的用户界面中实现请求变得困难。

例如，假设您可以通过下拉菜单中的 `Menultem` 或点击 Lexi 界面底部的页面图标来跳转到文档的最后一页（对于短文档来说，点击页面图标可能更方便）。如果我们通过继承将请求与 `Menultem` 关联，那么对于页面图标以及任何其他可能发出此类请求的小部件，我们都必须采取相同的做法。这可能会导致许多类的生成，类的数量接近于小部件类型数与请求数的乘积。

我们需要一个机制来使菜单项根据它们应当执行的请求进行参数化。这样我们可以避免子类的过多扩展，并允许在运行时实现更大的灵活性。我们可以通过一个函数来参数化 `Menultem`，但这不是一个完整的解决方案，至少有以下三个原因：

1. 它没有解决撤销/重做的问题。
2. 很难将状态与函数关联。例如，改变字体的函数需要知道使用的是哪种字体。
3. 函数难以扩展，而且难以重用它们的一部分。

这些问题表明，我们应该使用一个对象来参数化 `Menultem`，而不是函数。然后，我们可以使用继承来扩展和重用请求的实现。我们还可以在此对象中存储状态并实现撤销/重做功能。在这种情况下，我们又一次遇到了封装变化概念的问题，这里我们封装了请求。我们将每个请求封装在一个命令对象中。

### 命令类及其子类

首先，我们定义一个 `Command` 抽象类，提供发出请求的接口。基本接口由一个名为 `Execute` 的抽象操作组成。`Command` 的子类以不同的方式实现 `Execute`，以完成不同的请求。某些子类可能将部分或全部工作委托给其他对象，而其他子类可能完全独立完成请求（参见图 2.11）。然而，对于请求者来说，`Command` 对象就是一个 `Command` 对象——它们是统一处理的。

现在，`Menultem` 可以存储一个封装请求的 `Command` 对象（图 2.12）。我们给每个菜单项对象指定一个适合该菜单项的 `Command` 子类实例，就像我们为菜单项指定显示的文本一样。当用户选择某个菜单项时，`Menultem` 只是调用其 `Command` 对象的 `Execute` 来执行请求。注意，按钮和其他小部件可以像菜单项一样使用命令。

### 可撤销性

撤销/重做是交互式应用程序中的一个重要功能。为了撤销和重做命令，我们在 `Command` 的接口中添加了一个 `Unexecute` 操作。`Unexecute` 通过 `Execute` 存储的撤销信息来撤销先前 `Execute` 操作的效果。例如，在 `FontCommand` 中，`Execute` 操作会存储字体更改所影响的文本范围以及原始字体，而 `Unexecute` 操作则会将文本范围恢复为原始字体。

有时，撤销性必须在运行时确定。例如，选择更改字体的请求如果文本已经是该字体，则什么也不做。假设用户选择了一些文本，然后请求一个虚假的字体更改，那么撤销请求的结果应该是什么？虚假的更改是否应该导致撤销请求做出同样虚假的操作？大概不应该。如果用户多次重复同样的虚假字体更改，他不应该需要执行与该更改相同数量的撤销操作才能恢复到最后一次有效操作。如果命令执行的实际效果是“无”，那么就不需要对应的撤销请求。

因此，为了确定命令是否可撤销，我们在 `Command` 接口中添加了一个抽象的 `Reversible` 操作。`Reversible` 返回一个布尔值，子类可以根据运行时的条件重新定义该操作，以返回 `true` 或 `false`。

### 命令历史

支持任意级别的撤销和重做的最后一步是定义一个命令历史记录，即已执行（或已撤销）命令的列表。从概念上讲，命令历史记录如下所示：

每个圆圈代表一个 `Command` 对象。在此示例中，用户已发出四个命令。最左边的命令是最早发出的，然后是第二个最左边的命令，依此类推，直到最右边的命令，这是最近发出的命令。标记为“present”的线追踪最近执行（和撤销）的命令。

为了撤销最后一个命令，我们只需调用最右侧命令的 `Unexecute`：

撤销该命令后，我们将“present”线向左移动一位。如果用户再次选择撤销，下一个最右侧的命令将以相同方式被撤销，最终结果如下所示：

通过简单重复此过程，我们可以实现多个撤销级别。撤销级别的数量仅受命令历史长度的限制。

要重做刚刚撤销的命令，我们将执行相同的操作，但顺序相反。`present` 线右侧的命令是可以在未来重做的命令。

为了重做最后一个已撤销的命令，我们调用 `Execute` 来执行 `present` 线右侧的命令：

然后，我们将 `present` 线向前移动，以便下一个重做操作将重做后续命令。

当然，如果随后的操作不是另一个重做，而是撤销，那么将撤销 `present` 线左侧的命令。因此，用户可以根据需要有效地在时间上来回操作，以恢复错误。

### 命令模式

Lexi 的命令是命令模式（Command Pattern）的应用，该模式描述了如何封装请求。命令模式为发出请求提供了一个统一的接口，允许您配置客户端来处理不同的请求。接口屏蔽了客户端与请求实现之间的关系。一个命令可能将请求的部分或全部实现委托给其他对象。这对于像 Lexi 这样的应用程序非常合适，因为它们必须提供对散布在整个应用程序中的功能的集中访问。该模式还讨论了基于基本命令接口构建的撤销和重做机制。
